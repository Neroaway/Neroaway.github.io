<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F06%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%88Q-learing%20Sarsa%EF%BC%89%2F</url>
    <content type="text"><![CDATA[机器学习中强化学习算法———Q-learning Sarsa一. Q-learning1.算法思想Q-Learning是强化学习算法中值迭代的算法，Q即为Q（s,a）就是在某一时刻的 s 状态下(s∈S)，采取 a (a∈A)动作能够获得收益的期望，环境会根据agent的动作反馈相应的回报reward r，所以算法的主要思想就是将State与Action构建成一张Q-table来存储Q值，然后根据Q值来选取动作获得较大的收益。 2.算法概述 算法主要是通过不断的迭代使Q表不断更新。上图是Q-learning 的 伪代码。 比如运行到了 S2 处，那么现实中的 Q(S1,a2) = R + gamma * Q(S2,a2) ,通过Q表估计出来的为 Q(S1,a2). (其中 R代表的是当前所获得的奖励)。然后 更新产生的新的Q（S1，a2）= 老Q（S1,a2）+ α * 差距 ；其中 差距 = 现实的Q（S1,a2）- 估计的Q（S1，a2）. 3.通过Q-learning 实现的python 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import numpy as npimport pandas as pdimport timenp.random.seed(2)N_STATES = 6 # 距离宝藏的距离ACTIONS = ['left','right']EPSILON = 0.9 # 90%选择最优的动作 10%选择随机的动作ALPHA = 0.1 # learning rate 学习效率LAMBDA = 0.9 # 衰减值MAX_EPISODES = 13 # 最大回合FRESH_TIME = 0.1 # 走一步花的时间# 建立Q表def build_q_table(n_states, action): table = pd.DataFrame( np.zeros((n_states, len(action))), columns=action # action's name ) #print(table) return tabledef choose_action(state,q_table): # This is how to choose an action state_action = q_table.iloc[state, :] if (np.random.uniform() &gt; EPSILON) or (state_action.all() == 0): # 产生的随机数&gt;EPSILON或者都为0是 action_name = np.random.choice(ACTIONS) # 随机选择动作 else: action_name = state_action.idxmax() # 挑选最大的进行 return action_namedef get_env_feedback(S,A): if A == 'right': if(S == N_STATES-2): S_ = 'terminal' R = 1 else: S_ = S + 1 R = 0 else: R = 0 if S ==0: S_= S else: S_ = S - 1 return S_,Rdef update_env(S, episode ,step_counter): env_list = ['-']*(N_STATES-1) + ['T'] # '-------------T' our environment if S== 'terminal': interaction = 'Episode %s: total_steps = %s' % (episode+1,step_counter) print('\r&#123;&#125;'.format(interaction),end='') time.sleep(2) print('\r ', end='') else: env_list[S] = 'o' interaction = ''.join(env_list) print('\r&#123;&#125;'.format(interaction),end='') time.sleep(FRESH_TIME)# main part of RL loopdef rl(): q_table = build_q_table(N_STATES,ACTIONS) for episode in range(MAX_EPISODES): step_counter = 0 S = 0 is_terminates = False update_env(S,episode,step_counter) while not is_terminates: A = choose_action(S,q_table) S_,R = get_env_feedback(S,A) q_predict = q_table.loc[S,A] #loc == ix if S_ != 'terminal': q_target = R + LAMBDA * q_table.iloc[S_, :].max() else: q_target = R is_terminates = True q_table.loc[S,A] += ALPHA * (q_target - q_predict) S = S_ update_env(S,episode,step_counter+1) step_counter += 1 return q_tableif __name__ == '__main__': q_table = rl() print('\r\nQ-table:\n') print(q_table)]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法-----枚举]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%AE%97%E6%B3%95-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[例题一： 完美立方体例如： a^3 = b^3 + c^3 + d^3 的等式被称为完美立方体。 输入：一个正整数N（N &lt;= 100) 输出： 每行输出一个完美立方体。输出格式 ： Cube = a , Triple = (b,c,d) 其中 a,b,c,d所在位置分别用实际求出四元组值代入。 12345678910111213141516171819202122#完美立方体#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int N; cin&gt;&gt;N; for(int a = 2;a &lt;= N;++a)&#123; for(int b = 2;b &lt; a;++b)&#123; for(int c = b;c &lt; a; c++)&#123; for(int d = c;d &lt; a;++d)&#123; if(a*a*a == b*b*b + c*c*c + d*d*d) printf("Cube = %d , Triple = (%d,%d,%d)\n",a,b,c,d); return 0; &#125; &#125; &#125; &#125;&#125;# 例题 二：生理周期题目阐述：人有体力、情商、智商的高峰日子，它们分别每隔 23天、28天和33天出现一次。对于每个人，我们想知道何时三个高峰落在同一天。给定三个高峰出现的日子p,e和 i（不一定是第一次高峰出现的日子）, 再给定另一个指定的日子d，你的任务是输出日子d之后，下一次三个高峰落在同一 天的日子（用距离d的天数表示）。例如：给定日子为10，下次出现三个高峰同一天的日子是12，则输出2。 生理周期输入​ 输入四个整数：p, e, i和d。 p, e, i分别表示体力、情感和智力高峰出现的日子。d是给定的日子，可能小于p, e或 i。所有给定日子是非负的并且小于或等于365，所求的日子小于或等于21252 输出​ 从给定日子起，下一次三个高峰同一天的日子（距离给定日子的天数）。 输入样例0 0 0 0 0 0 0 100 5 20 34 325 4 5 6 7 283 102 23 320 203 301 203 40 -1 -1 -1 -1 输出样例Case 1: the next triple peak occurs in 21252 days. Case 2: the next triple peak occurs in 21152 days. Case 3: the next triple peak occurs in 19575 days. Case 4: the next triple peak occurs in 16994 days. Case 5: the next triple peak occurs in 8910 days. Case 6: the next triple peak occurs in 10789 days. 代码1234567891011121314151617#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std;#define N 21252int main()&#123;int p,e,i,d,caseNo = 0;while( cin &gt;&gt; p &gt;&gt; e &gt;&gt;i &gt;&gt;d &amp;&amp; p!= -1) &#123; ++ caseNo; int k; for(k = d+1; (k-p)%23; ++k); for(; (k-e)%28; k+= 23); for(; (k-i)%33; k+= 23*28); cout &lt;&lt; "Case " &lt;&lt; caseNo &lt;&lt; ": the next triple peak occurs in " &lt;&lt; k-d &lt;&lt; " days." &lt;&lt; endl; &#125; return 0;&#125; 三：称硬币题目阐述：有12枚硬币。其中有11枚真币和1枚假币。假币和真币重量不同，但不知道假币比真币轻还是重。现在，用一架天平称了这些币三次，告诉你称的结果，请你找出假币并且确定假币是轻是重（数据保证一定能找出来）。 输入：​ 第一行是测试数据组数。 每组数据有三行，每行表示一次称量的结果。银币标号为 A-L。每次称量的结果用三个以空格隔开的字符串表示：天平左边放置的硬币 天平右边放置的硬币 平衡状态。其中平衡 状态用up&#39;&#39;,down’’, 或 even’’表示, 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。 输出： 输出哪一个标号的银币是假币，并说明它比真币轻还是重。 输入样例:1ABCD EFGH evenABCI EFJK upABIJ EFGH even 输出样例：K is the counterfeit coin and it is light. 解题思路 对于每一枚硬币先假设它是轻的，看这样是否符合称量结果。如果符合，问题即解决。如果不符合，就假设它是重的，看是否符合称量结果。把所有硬币都试一遍，一定能找到特殊硬币。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;char Left[3][4];char Right[3][4];char result[3][4];bool IsFake(char c , bool light);int main()&#123; int t; cin&gt;&gt;t; while (t--)&#123; for(int i = 0;i &lt; 3;++i) cin&gt;&gt;Left[i]&gt;&gt;Right[i]&gt;&gt;result[i]; for(char c = 'A';c &lt;= 'L';c++)&#123; if(IsFake(c, true))&#123; cout&lt;&lt;c&lt;&lt;"is the counterfeit coin and it is light.\n"; break; &#125; else if(IsFake(c , false))&#123; cout&lt;&lt;c&lt;&lt;"is the counterfeit coin and it is the heavy.\n"; break; &#125; &#125; &#125; return 0;&#125;bool IsFake(char c , bool light)&#123; for(int i = 0 ;i &lt;3 ;++i) &#123; char *pLeft, *pRight; if (light) &#123; pLeft = Left[i]; pRight = Right[i]; &#125; else &#123; pRight = Left[i]; pLeft = Right[i]; &#125; switch (result[i][0]) &#123; case 'u': if (strchr(pRight, c) == NULL) return false; break; case 'e': if (strchr(pRight, c) == strchr(pLeft, c)) return false; break; case 'd': if (strchr(pLeft, c) == NULL) return false; break; &#125; &#125; return true;&#125; 四： 熄灯问题题目概述：– 有一个由按钮组成的矩阵, 其中每行有6个按钮, 共5行 – 每个按钮的位置上有一盏灯 – 当按下一个按钮后, 该按钮以及周围位置(上边, 下边, 左 边, 右边)的灯都会改变状态 ​ 与一盏灯毗邻的多个按钮被按下时,一个操作会抵消另一次操作的结果 ​ 给定矩阵中每盏灯的初始状态，求一种按按钮方案，使得所有的灯都熄灭 输入： – 第一行是一个正整数N, 表示需要解决的案例数 – 每个案例由5行组成, 每一行包括6个数字 – 这些数字以空格隔开, 可以是0或1 – 0 表示灯的初始状态是熄灭的 – 1 表示灯的初始状态是点亮的 输出： – 对每个案例, 首先输出一行,输出字符串 “PUZZLE #m”, 其中m是该案例的序号– 接着按照该案例的输入格式输出5行• 1 表示需要把对应的按钮按下• 0 表示不需要按对应的按钮• 每个数字以一个空格隔开 #]]></content>
      <tags>
        <tag>C++算法与数据结构(基础）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
